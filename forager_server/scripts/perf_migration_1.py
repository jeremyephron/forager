# Generated by Django 3.1.1 on 2021-06-03 06:21

from collections import defaultdict
from enum import IntEnum
import json
import operator

from django.db import migrations, models
from tqdm import tqdm


APP_NAME = "forager_server_api"
ID_FIELD = (
    "id",
    models.AutoField(
        auto_created=True,
        primary_key=True,
        serialize=False,
        verbose_name="ID",
    ),
)
MEDIUM_STRING_LENGTH = 300
LONG_STRING_LENGTH = 600


class LabelValue(IntEnum):
    TOMBSTONE = -1
    POSITIVE = 1
    NEGATIVE = 2
    HARD_NEGATIVE = 3
    UNSURE = 4
    CUSTOM = 5


def nest_anns(anns, nest_category=True, nest_lf=True):
    if nest_category and nest_lf:
        data = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
        for ann in anns:
            # Only use most recent perframe ann
            k = ann.dataset_item.pk
            c = ann.label_category
            u = ann.label_function
            data[k][c][u].append(ann)
    elif nest_category:
        data = defaultdict(lambda: defaultdict(list))
        for ann in anns:
            # Only use most recent perframe ann
            k = ann.dataset_item.pk
            c = ann.label_category
            data[k][c].append(ann)
    elif nest_lf:
        data = defaultdict(lambda: defaultdict(list))
        for ann in anns:
            # Only use most recent perframe ann
            k = ann.dataset_item.pk
            u = ann.label_function
            data[k][u].append(ann)
    else:
        data = defaultdict(list)
        for ann in anns:
            # Only use most recent perframe ann
            k = ann.dataset_item.pk
            data[k].append(ann)
    return data


def delete_google(apps, schema_editor):
    db_alias = schema_editor.connection.alias

    DatasetItem = apps.get_model(APP_NAME, "DatasetItem")
    DatasetItem.objects.using(db_alias).filter(google=True).delete()


def remove_deprecated_annotations(apps, schema_editor):
    db_alias = schema_editor.connection.alias

    Annotation = apps.get_model(APP_NAME, "Annotation")
    Annotation.objects.using(db_alias).exclude(label_type="klabel_frame").delete()

    nested = nest_anns(Annotation.objects.using(db_alias).all())
    for by_k in tqdm(nested.values()):
        for by_c in by_k.values():
            for by_u in by_c.values():
                assert isinstance(by_u, list)

                # by_u = List[Annotation]
                # Delete all but the most recent non-tombstone annotations
                most_recent_pk = max(by_u, key=operator.attrgetter("created")).pk
                for ann in by_u:
                    if ann.pk == most_recent_pk:
                        label_data = json.loads(ann.label_data)
                        if label_data["value"] != LabelValue.TOMBSTONE:
                            continue
                    ann.delete()


def populate_user_category_and_mode(apps, schema_editor):
    db_alias = schema_editor.connection.alias

    Annotation = apps.get_model(APP_NAME, "Annotation")
    User = apps.get_model(APP_NAME, "User")
    Category = apps.get_model(APP_NAME, "Category")
    Mode = apps.get_model(APP_NAME, "Mode")

    users = set()
    categories = set()
    modes = set()

    for ann in tqdm(Annotation.objects.using(db_alias).all()):
        user = ann.label_function
        category = ann.label_category
        label_data = json.loads(ann.label_data)
        value = LabelValue(label_data["value"])
        mode = label_data["custom_value"] if value == LabelValue.CUSTOM else value.name

        users.add(user)
        categories.add(category)
        modes.add(mode)

    User.objects.using(db_alias).bulk_create([User(email=u) for u in users])
    Category.objects.using(db_alias).bulk_create([Category(name=c) for c in categories])
    Mode.objects.using(db_alias).bulk_create([Mode(name=m) for m in modes])


def populate_new_annotation_fields(apps, schema_editor):
    db_alias = schema_editor.connection.alias

    Annotation = apps.get_model(APP_NAME, "Annotation")
    User = apps.get_model(APP_NAME, "User")
    Category = apps.get_model(APP_NAME, "Category")
    Mode = apps.get_model(APP_NAME, "Mode")

    for ann in tqdm(Annotation.objects.using(db_alias).all()):
        user = ann.label_function
        category = ann.label_category
        label_data = json.loads(ann.label_data)
        value = LabelValue(label_data["value"])
        mode = label_data["custom_value"] if value == LabelValue.CUSTOM else value.name

        ann.user = User.objects.using(db_alias).get(email=user)
        ann.category = Category.objects.using(db_alias).get(name=category)
        ann.mode = Mode.objects.using(db_alias).get(name=mode)
        if "mode" in label_data:
            ann.misc_data = {"created_by": label_data["mode"]}
        ann.save()


class Migration(migrations.Migration):
    dependencies = [
        ("forager_server_api", "0007_dataset_hidden"),
    ]

    operations = [
        migrations.RenameField("Dataset", "directory", "train_directory"),
        migrations.DeleteModel("EmbeddingSet"),
        migrations.AlterField(
            "DNNModel",
            "checkpoint_path",
            models.CharField(max_length=LONG_STRING_LENGTH, null=True),
        ),
        migrations.AlterField(
            "DNNModel",
            "output_directory",
            models.CharField(max_length=LONG_STRING_LENGTH, null=True),
        ),
        migrations.CreateModel(
            "User",
            fields=[
                ID_FIELD,
                ("email", models.EmailField(unique=True)),
            ],
        ),
        migrations.CreateModel(
            "Category",
            fields=[
                ID_FIELD,
                (
                    "name",
                    models.CharField(max_length=MEDIUM_STRING_LENGTH, unique=True),
                ),
            ],
        ),
        migrations.CreateModel(
            "Mode",
            fields=[
                ID_FIELD,
                (
                    "name",
                    models.CharField(max_length=MEDIUM_STRING_LENGTH, unique=True),
                ),
            ],
        ),
        migrations.AddField(
            "Annotation",
            "user",
            models.ForeignKey(
                on_delete=models.deletion.CASCADE,
                to=f"{APP_NAME}.user",
                null=True,
            ),
        ),
        migrations.AddField(
            "Annotation",
            "category",
            models.ForeignKey(
                on_delete=models.deletion.CASCADE,
                to=f"{APP_NAME}.category",
                null=True,
            ),
        ),
        migrations.AddField(
            "Annotation",
            "mode",
            models.ForeignKey(
                on_delete=models.deletion.CASCADE,
                to=f"{APP_NAME}.mode",
                null=True,
            ),
        ),
        migrations.AddField("Annotation", "bbox_x1", models.FloatField(null=True)),
        migrations.AddField("Annotation", "bbox_y1", models.FloatField(null=True)),
        migrations.AddField("Annotation", "bbox_x2", models.FloatField(null=True)),
        migrations.AddField("Annotation", "bbox_y2", models.FloatField(null=True)),
        migrations.AddField("Annotation", "misc_data", models.JSONField(default=dict)),
        migrations.RunPython(delete_google),
        migrations.RunPython(remove_deprecated_annotations),
        migrations.RunPython(populate_user_category_and_mode),
        migrations.RunPython(populate_new_annotation_fields),
    ]
